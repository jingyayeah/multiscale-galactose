del1968.fig4$BSA[k], del1968.fig4$volLiver[k]-del1968.fig4$volLiverSd[k], col=col)
}
xname <- 'bodyweight'
yname <- 'volLiver'
selection <- c('study', 'gender', xname, yname)
data <- rbind(naw1998[, selection],
vau2002.fig2[, selection])
m1 <- linear_regression(data, xname, yname)
reg.models[[id]] = m1
reg.data[[id]] = data
id = id + 1
makeFigure(data, m1, main='Liver volume vs. bodyweight', xname='bodyweight', yname='volLiver',
xlab='bodyweight [kg]', ylab='Liver volume [ml]',
xlim=c(40,120), ylim=c(500, 2500))
head(del1968.fig1)
for (k in 1:nrow(del1968.fig1)){
print(k)
# horizontal
sex <- del1968.fig1$gender[k]
col <- gender.cols[which(gender.levels == sex)]
segments(del1968.fig1$weightMin[k], del1968.fig1$volLiver[k],
del1968.fig1$weightMax[k], del1968.fig1$volLiver[k], col=col)
# vertical
segments(del1968.fig1$weight[k], del1968.fig1$volLiver[k]+del1968.fig1$volLiverSd[k],
del1968.fig1$weight[k], del1968.fig1$volLiver[k]-del1968.fig1$volLiverSd[k], col=col)
}
head(tom1965)
for (k in 1:nrow(tom1965)){
sex <- tom1965$gender[k]
col <- gender.cols[which(gender.levels == sex)]
segments(tom1965$bodyweight[k]-tom1965$bodyweightSd[k], tom1965$volLiver[k],
tom1965$bodyweight[k]+tom1965$bodyweightSd[k], tom1965$volLiver[k], col=col)
segments(tom1965$bodyweight[k], tom1965$volLiver[k]+tom1965$volLiverSd[k],
tom1965$bodyweight[k], tom1965$volLiver[k]-tom1965$volLiverSd[k], col=col)
}
xname <- 'age'
yname <- 'flowLiver'
selection <- c('study', 'gender', xname, yname)
data <- rbind( win1965[, selection],
wyn1989.fig3a[, selection],
bra1945[, selection],
zol1999[, selection],
sch1945[, selection],
wyn1990[, selection])
m1 <- linear_regression(data, xname, yname)
reg.models[[id]] = m1
reg.data[[id]] = data
id = id + 1
makeFigure(data, m1, main='Blood flow vs. age',xname='age', yname='flowLiver',
xlab='Age [years]', ylab='Blood flow liver [ml/min]',
xlim=c(0,90), ylim=c(400,3000))
xname <- 'BSA'
yname <- 'flowLiver'
selection <- c('study', 'gender', xname, yname)
data <- rbind(bra1945[, selection],
sch1945[, selection])
m1 <- linear_regression(data, xname, yname)
reg.models[[id]] = m1
reg.data[[id]] = data
id = id + 1
makeFigure(data, m1, main='Blood flow vs. BSA', xname='BSA', yname='flowLiver',
xlab='Body surface are (BSA) [m^2]', ylab='Blood flow liver [ml/min]',
xlim=c(1.0,2.5), ylim=c(400,2500))
xname <- 'age'
yname <- 'perfusion'
selection <- c('study', 'gender', xname, yname)
data <- rbind( wyn1989.fig4[, selection])
m1 <- linear_regression(data, xname, yname)
reg.models[[id]] = m1
reg.data[[id]] = data
id = id + 1
makeFigure(data, m1, main='Perfusion vs. age', xname='age', yname='perfusion',
xlab='Age [years]', ylab='Perfusion [ml/min/ml]',
xlim=c(0,90), ylim=c(0,2))
xname <- 'age'
yname <- 'perfusion'
selection <- c('study', 'gender', xname, yname)
data <- rbind( wyn1989.fig4[, selection])
m1 <- linear_regression(data, xname, yname)
reg.models[[id]] = m1
reg.data[[id]] = data
id = id + 1
makeFigure(data, m1, main='Perfusion vs. age', xname='age', yname='perfusion',
xlab='Age [years]', ylab='Perfusion [ml/min/ml]',
xlim=c(0,90), ylim=c(0,2))
xname <- 'BSA'
yname <- 'flowLiver'
selection <- c('study', 'gender', xname, yname)
data <- rbind(bra1945[, selection],
sch1945[, selection])
m1 <- linear_regression(data, xname, yname)
reg.models[[id]] = m1
reg.data[[id]] = data
id = id + 1
makeFigure(data, m1, main='Blood flow vs. BSA', xname='BSA', yname='flowLiver',
xlab='Body surface are (BSA) [m^2]', ylab='Blood flow liver [ml/min]',
xlim=c(1.0,2.5), ylim=c(400,2500))
xname <- 'age'
yname <- 'flowLiver'
selection <- c('study', 'gender', xname, yname)
data <- rbind( win1965[, selection],
wyn1989.fig3a[, selection],
bra1945[, selection],
zol1999[, selection],
sch1945[, selection],
wyn1990[, selection])
m1 <- linear_regression(data, xname, yname)
reg.models[[id]] = m1
reg.data[[id]] = data
id = id + 1
makeFigure(data, m1, main='Blood flow vs. age',xname='age', yname='flowLiver',
xlab='Age [years]', ylab='Blood flow liver [ml/min]',
xlim=c(0,90), ylim=c(400,3000))
xname <- 'age'
yname <- 'perfusion'
selection <- c('study', 'gender', xname, yname)
data <- rbind( wyn1989.fig4[, selection])
m1 <- linear_regression(data, xname, yname)
reg.models[[id]] = m1
reg.data[[id]] = data
id = id + 1
makeFigure(data, m1, main='Perfusion vs. age', xname='age', yname='perfusion',
xlab='Age [years]', ylab='Perfusion [ml/min/ml]',
xlim=c(0,90), ylim=c(0,2))
x <- 1:20
beta0 <- 1
beta1 <- 2
sigma <- 0.5
output <- replicate(1000, rnorm(length(x),beta0+beta1*x,sigma))
head(output)
summary(output)
str(output)
matplot(output)
x <- runif(100, min=0, max=10)
beta0 <- 1
beta1 <- 2
sigma <- 0.5
output <- replicate(100, rnorm(length(x),beta0+beta1*x,sigma))
# will replicate, 1000 times, sampling from the predictive distribution of a Gaussian
# linear regression model. Conceptually, this is equivalent to doing something like
str(output)
matplot(output)
x <- order(runif(100, min=0, max=10))
x
x <- x[order(x))
x <- runif(100, min=0, max=10)
x <- x[order(x)]
x
beta0 <- 1
beta1 <- 2
sigma <- 0.5
output <- replicate(100, rnorm(length(x),beta0+beta1*x,sigma))
matplot(output)
library(MASS)
data(geyser)
str(geyser)
data(geyser)
plot(duration, waiting)
with(geyser, plot(duration, waiting))
fit.ols <- lm(waiting~duration, data=geyser)
fit.ols
abline(fit.ols, col='blue')
summary(fit.ols)
str(summary(fit.ols))
summary(fit.ols)
rgeyser <- function() {
n <- nrow(geyser)
# use the residual standard error
sigma <- summary(fit.ols)$sigma
new.waiting <- rnorm(n, mean=fitted(fit.ols), sd=sigma)
new.geyser <- data.frame(duration=geyser$duration,
waiting=new.waiting)
return(new.geyser)
}
plot(density(geyser$waiting),xlab="waiting",main="",sub="")
lines(density(rgeyser()$waiting),lty=2)
lines(density(rgeyser()$waiting),lty=2)
lines(density(rgeyser()$waiting),lty=2)
lines(density(rgeyser()$waiting),lty=2)
lines(density(rgeyser()$waiting),lty=2)
lines(density(rgeyser()$waiting),lty=2)
lines(density(rgeyser()$waiting),lty=2)
lines(density(rgeyser()$waiting),lty=2)
lines(density(rgeyser()$waiting),lty=2)
lines(density(rgeyser()$waiting),lty=2)
with(geyser, plot(duration, waiting))
plot(density(geyser$waiting),xlab="waiting",main="",sub="")
lines(density(rgeyser()$waiting),lty=2)
plot(duration, waiting, data=geyser)
plot(duration, waiting, data=rgeyser())
with(rgeyser(), plot(duration, waiting))
with(rgeyser(), plot(duration, waiting))
with(rgeyser(), plot(duration, waiting))
with(rgeyser(), plot(duration, waiting))
plot(density(geyser$duration),xlab="duration",main="",sub="")
plot(density(geyser$duration),xlab="duration",main="",sub="")
with(rgeyser(), plot(duration, waiting))
plot(geyser$duration,geyser$waiting,xlab="duration",ylab="waiting")
abline(fit.ols)
points(rgeyser(),pch=20,cex=0.5)
plot(geyser$duration, fit.ols$residuals)
plot(geyser$duration, fit.ols$residuals)
library(MASS)
data(geyser)
geyser.lm <- lm(waiting~duration, data=geyser)
summary(geyser.lm)
resample.geyser <- function(){
sample.rows <- resample(1:nrow(geyser))
return(sample.rows)
}
help(resample)
help(sample)
sample(1:10)
resample.geyser <- function(){
sample.rows <- sample(1:nrow(geyser))
return(sample.rows)
}
est.waiting.on.duration <- function(subset, data=geyser){
fit <- lm(waiting ~ duration, data=data, subset=subset)
return(coefficients(fit))
}
# Bootstrapped confidence intervals
geyser.lm.cis <- function(B,alpha){
# distributions of coefficients under bootstrap
tboot <- replicate(B, est.waiting.on.duration(resample.geyser()))
low.quantiles <- apply(tboot, 1, quantile, probs=alpha/2)
high.quantiles <- apply(tboot, 1, quantile, probs=1-alpha/2)
low.cis <- 2*coefficients(geyser.lm) -high.quantiles
high.cis <- 2*coefficients(geyser.lm) - low.quantiles
cis <- rbind(low.cis, high.cis)
rownames(cis) <- as.character(c(alpha/2, 1-alpha/2))
return(cis)
}
signif(geyser.lm.cis(B=1e4, alpha=0.05),3)
resample.geyser <- function(){
sample.rows <- sample(1:nrow(geyser))
return(sample.rows)
}
resample.geyser()
# estimator
est.waiting.on.duration <- function(subset, data=geyser){
fit <- lm(waiting ~ duration, data=data, subset=subset)
return(coefficients(fit))
}
signif(geyser.lm.cis(B=1e4, alpha=0.05),3)
geyser.lm.cis <- function(B,alpha) {
tboot <- replicate(B,
est.waiting.on.duration(resample.geyser()))
low.quantiles <- apply(tboot,1,quantile,probs=alpha/2)
high.quantiles <- apply(tboot,1,quantile,probs=1-alpha/2)
low.cis <- 2*coefficients(geyser.lm) - high.quantiles
high.cis <- 2*coefficients(geyser.lm) - low.quantiles
cis <- rbind(low.cis,high.cis)
rownames(cis) <- as.character(c(alpha/2,1-alpha/2))
return(cis)
}
signif(geyser.lm.cis(B=1e4, alpha=0.05),3)
resample.geyser <- function(){
sample.rows <- sample(1:nrow(geyser), replace = TRUE)
return(sample.rows)
}
# estimator
est.waiting.on.duration <- function(subset, data=geyser){
fit <- lm(waiting ~ duration, data=data, subset=subset)
return(coefficients(fit))
}
# Bootstrapped confidence intervals
geyser.lm.cis <- function(B,alpha) {
tboot <- replicate(B,
est.waiting.on.duration(resample.geyser()))
low.quantiles <- apply(tboot,1,quantile,probs=alpha/2)
high.quantiles <- apply(tboot,1,quantile,probs=1-alpha/2)
low.cis <- 2*coefficients(geyser.lm) - high.quantiles
high.cis <- 2*coefficients(geyser.lm) - low.quantiles
cis <- rbind(low.cis,high.cis)
rownames(cis) <- as.character(c(alpha/2,1-alpha/2))
return(cis)
}
signif(geyser.lm.cis(B=1e4, alpha=0.05),3)
library(np)
install.packages('np')
install.packages('np')
install.packages('np')
library(np)
library(np)
npr.waiting.on.duration <- function(subset, data=geyser, tol=0.1, ftol=0.1){
bw <- npregbw(waiting ~ duration, data=data, subset=subset, tol=tol, ftol=ftol)
fit <- npreg(bw)
return(fit)
}
geyser.npr <- npr.waiting.on.duration(1:nrow(geyser))
plot(geyser.npr)
npr.cis <- function(B,alpha) {
tboot <- replicate(B,
eval.npr(npr.waiting.on.duration(resample.geyser())))
low.quantiles <- apply(tboot,1,quantile,probs=alpha/2)
high.quantiles <- apply(tboot,1,quantile,probs=1-alpha/2)
low.cis <- 2*main.curve - high.quantiles
high.cis <- 2*main.curve - low.quantiles
cis <- rbind(low.cis,high.cis)
return(list(cis=cis,tboot=t(tboot)))
}
geyser.npr.cis <- npr.cis(B=800, alpha=0.05)
eval.npr <- function(npr) {
return(predict(npr,newdata=evaluation.points))
}
geyser.npr.cis <- npr.cis(B=800, alpha=0.05)
evaluation.points <- seq(from=0.8,to=5.5,length.out=200)
evaluation.points <- data.frame(duration=evaluation.points)
eval.npr <- function(npr) {
return(predict(npr,newdata=evaluation.points))
}
npr.cis <- function(B,alpha) {
tboot <- replicate(B,
eval.npr(npr.waiting.on.duration(resample.geyser())))
low.quantiles <- apply(tboot,1,quantile,probs=alpha/2)
high.quantiles <- apply(tboot,1,quantile,probs=1-alpha/2)
low.cis <- 2*main.curve - high.quantiles
high.cis <- 2*main.curve - low.quantiles
cis <- rbind(low.cis,high.cis)
return(list(cis=cis,tboot=t(tboot)))
}
geyser.npr.cis <- npr.cis(B=800, alpha=0.05)
main.curve <- eval.npr(geyser.npr)
npr.cis <- function(B,alpha) {
tboot <- replicate(B,
eval.npr(npr.waiting.on.duration(resample.geyser())))
low.quantiles <- apply(tboot,1,quantile,probs=alpha/2)
high.quantiles <- apply(tboot,1,quantile,probs=1-alpha/2)
low.cis <- 2*main.curve - high.quantiles
high.cis <- 2*main.curve - low.quantiles
cis <- rbind(low.cis,high.cis)
return(list(cis=cis,tboot=t(tboot)))
}
geyser.npr.cis <- npr.cis(B=800, alpha=0.05)
plot(0, type='n', xlim=c(0.8, 5.5), ylim=c(0,100),
xlab="Duration (min)", ylab="Waiting (min)")
for (i in 1:800) {
lines(evaluation.points$duration, geyser.npr.cis$tboot[i,], lwd=0.1, col='grey')
}
lines(evaluation.points$duration,geyser.npr.cis$cis[1,])
lines(evaluation.points$duration,geyser.npr.cis$cis[2,])
lines(evaluation.points$duration,main.curve)
rug(geyser$duration,side=1)
points(geyser$duration,geyser$waiting)
x <- rnorm(100, 0, 3)
y = 3 - 2*x + rnorm(100, 0, sapply(x, function(x){1+0.5*x^2}))
plot(x, y)
abline(a=3, b=-2, col="grey")
fit.ols <- lm(y ~ x)
abline(fit.ols, lty=2)
y = 3 - 2*x + rnorm(100, 0, sapply(x, function(x){1+0.5*x^2}))
ols.heterosked.example <- function(n){
y = 3 - 2*x + rnorm(100, 0, sapply(x, function(x){1+0.5*x^2}))
fit.ols <- lm(y ~ x)
# return errors
return(fit.ols$coefficients - c(3,2))
}
ols.heterosked.example <- function(n){
y = 3 - 2*x + rnorm(100, 0, sapply(x, function(x){1+0.5*x^2}))
fit.ols <- lm(y ~ x)
# return errors
return(fit.ols$coefficients - c(3,2))
}
ols.heterosked.error.stats <- function(n, m=10000){
ols.errors.raw <- t(replicate(m, ols.heterosked.example(n)))
# transpose gives a matrix with named columns
intercept.sd <- sd(ols.errors.raw[, "(Intercept)"])
slope.sp <- sd(ols.errors.raw[, "x"])
return(list(intercept.sd=intercept.sd, slope.sd=slope.sd)
}
plot(x, residuals(fit.ols))
plot(x, (residuals(fit.ols))^2)
ols.heterosked.error.stats <- function(n, m=10000){
ols.errors.raw <- t(replicate(m, ols.heterosked.example(n)))
# transpose gives a matrix with named columns
intercept.sd <- sd(ols.errors.raw[, "(Intercept)"])
slope.sp <- sd(ols.errors.raw[, "x"])
return(list(intercept.sd=intercept.sd, slope.sd=slope.sd)
}
ols.heterosked.error.stats <- function(n, m=10000){
ols.errors.raw <- t(replicate(m, ols.heterosked.example(n)))
# transpose gives a matrix with named columns
intercept.sd <- sd(ols.errors.raw[, "(Intercept)"])
slope.sp <- sd(ols.errors.raw[, "x"])
return(list(intercept.sd=intercept.sd, slope.sd=slope.sd))
}
ols.heterosked.error.stats(100)
ols.heterosked.error.stats <- function(n, m=10000){
ols.errors.raw <- t(replicate(m, ols.heterosked.example(n)))
# transpose gives a matrix with named columns
intercept.sd <- sd(ols.errors.raw[, "(Intercept)"])
slope.sd <- sd(ols.errors.raw[, "x"])
return(list(intercept.sd=intercept.sd, slope.sd=slope.sd))
}
ols.heterosked.error.stats(100)
fit.wls <- lm(y~x, weights=1/(1+0.5*x^2))
x <- rnorm(100, 0, 3)
y = 3 - 2*x + rnorm(100, 0, sapply(x, function(x){1+0.5*x^2}))
plot(x, y)
abline(a=3, b=-2, col="grey")
fit.ols <- lm(y ~ x)
abline(fit.ols, lty=2)
# using weighted linear regression
fit.wls <- lm(y~x, weights=1/(1+0.5*x^2))
abline(fit.wls, lty=3)
require(np)
plot(x, residuals(fit.ols)^2, ylab="squared residuals")
curve(1+x^2/2, col="grey", add=TRUE)
require(np)
var1 <- npreg(residuals(fit.ols)^2 ~ x)
grid.x <- seq(from=min(x), to=max(x), length.out=300)
lines(grid.x, predict(var1, exdat=grid.x))
fit.wls1 <- lm(y~x,weights=1/fitted(var1))
plot(x,y)
abline(a=3,b=-2,col="grey")
abline(fit.ols,lty=2)
abline(fit.wls1,lty=3)
plot(x,(residuals(fit.ols))^2,ylab="squared residuals")
points(x,(residuals(fit.wls1))^2,pch=15)
lines(grid.x,predict(var1,exdat=grid.x))
var2 <- npreg(residuals(fit.wls1)^2 ~ x)
curve((1+x^2/2)^2,col="grey",add=TRUE)
lines(grid.x,predict(var2,exdat=grid.x),lty=3)
iterative.wls <- function(x,y,tol=0.01,max.iter=100) {
iteration <- 1
old.coefs <- NA
regression <- lm(y~x)
coefs <- coefficients(regression)
while (is.na(old.coefs) ||
((max(coefs - old.coefs) > tol) && (iteration < max.iter))) {
variance <- npreg(residuals(regression)^2 ~ x)
old.coefs <- coefs
iteration <- iteration+1
regression <- lm(y~x,weights=1/fitted(variance))
coefs <- coefficients(regression)
}
return(list(regression=regression,variance=variance,iterations=iteration))
}
iterative.wls(x,y)
library(MASS)
data(geyser)
plot(geyser$duration, residuals(fit.ols)^2, cex=0.5, pch=16,
main="Squared residuals and variance estimates versus geyser duration",
xlab="Duration [min]",
xlab=expression("Squared residuals of linear model "([min^2]))
plot(geyser$duration, residuals(fit.ols)^2, cex=0.5, pch=16,
main="Squared residuals and variance estimates versus geyser duration",
xlab="Duration [min]",
xlab=expression("Squared residuals of linear model "(min^2))
plot(geyser$duration, residuals(fit.ols)^2, cex=0.5, pch=16,
main="Squared residuals and variance estimates versus geyser duration",
xlab="Duration [min]",
xlab=expression("Squared residuals of linear model "(min^2)))
plot(geyser$duration, residuals(fit.ols)^2, cex=0.5, pch=16,
main="Squared residuals and variance estimates versus geyser duration",
xlab="Duration [min]",
xlab=expression("Squared residuals of linear model "(min^2)))
plot(geyser$duration, residuals(fit.ols)^2, cex=0.5, pch=16,
main="Squared residuals and variance estimates versus geyser duration",
xlab="Duration [min]",
ylab=expression("Squared residuals of linear model "(min^2)))
fit.ols <- lm(waiting ~ duration, data=geyser)
plot(geyser$duration, residuals(fit.ols)^2, cex=0.5, pch=16,
main="Squared residuals and variance estimates versus geyser duration",
xlab="Duration [min]",
ylab=expression("Squared residuals of linear model "(min^2)))
geyser.var <- npreg(residuals(fit.ols^2 ~ geyser$duration)
geyser.var <- npreg(residuals(fit.ols)^2 ~ geyser$duration)
geyser.var <- npreg(residuals(fit.ols)^2 ~ geyser$duration)
duration.order <- order(geyser$duration)
lines(geyser$duration[duration.order], fitted(geyser.var)[duration.order])
abline(h=summary(fit.ols)$sigma^2, lty="dashed")
legend("topleft",
legend=c("data", "kernel variance", "homoskedastic (OLS)"),
lty=c(-1,1,2), pch=c(16,-1,-1))
plot(geyser.var)
abline(h=summary(fit.ols)$sigma^2, lty=2)
duration.grid <- seq(from=min(geyser$duration), to=max(geyser$duration), length.out=300)
one.var.func <- function(){
fit <- lm(waiting ~ duration, data=rgeyser())
var.func <- npreg(residuals(fit)^2 ~ geyser$duration)
lines(duration.grid, predict(var.func, exdat=duration.grid), col="grey")
}
invisible(replicate(10, one.var.func())
invisible(replicate(10, one.var.func()))
invisible(replicate(10, one.var.func()))
rm(list = ls())
setwd('/home/mkoenig/multiscale-galactose/experimental_data/NHANES')
load(file='data/nhanes.dat')
head(nhanes)
# Load prepared NHANES data
rm(list = ls())
setwd('/home/mkoenig/multiscale-galactose/experimental_data/NHANES')
load(file='data/nhanes_data.dat')
head(data)
# General spline fitting
x <- data$RIDAGEYR
y <- data$BMXWT
plot(x, y)
sp.fit <- res <- smooth.spline(x, y, cv=FALSE)
lines(sp.fit, col='blue', lwd = 3)
sp.fit2 <- res <- smooth.spline(x, y, spar=0.7)
lines(sp.fit2, col='orange', lwd = 3)
rug(x, side=1, col="grey"); rug(y, side=2, col="grey")
grid.x <- seq(min=min(x), max=max(x), length.out=length(x))
grid.x <- seq(from=min(x), to=max(x), length.out=length(x))
fit.ks <- npreg(y~x); lines(grid.x, predict(fit.ks, exdat=grid.x), col="red", lwd=3, lty=2)
fit.ll <- npreg(y~x, regtype="ll"); lines(grid.x, predict(fit.ks, exdat=grid.x), col="green", lwd=3, lty=2)
library(Lock5Data)
install.package('Lock5Data')
install.packages('Lock5Data')
