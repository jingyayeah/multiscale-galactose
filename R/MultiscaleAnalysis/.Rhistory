# find the simulation rows for the level
gal_rows <- which(pars[[f.level]]==p.level)
# plot all the single simulations for the level
for (k in gal_rows){
points(x[[id]][[k]]$time, x[[id]][[k]][[2]],
type='l', col=rgb(0.5,0.5,0.5, alpha=0.1 ))
}
}
par(mfrow=c(1,1))
# create subplot for all the different levels
nrow = ceiling(sqrt(length(plot.levels)))
par(mfrow=c(nrow, nrow))
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
# empty plot
plot(numeric(0), numeric(0), xlim=c(time.min, time.max), ylim=c(0,0.2))
# find the simulation rows for the level
gal_rows <- which(pars[[f.level]]==p.level)
# plot all the single simulations for the level
for (k in gal_rows){
points(x[[id]][[k]]$time, x[[id]][[k]][[2]],
type='l', col=rgb(0.5,0.5,0.5, alpha=0.1 ))
}
}
par(mfrow=c(1,1))
xlimits <- c(0.0, 10000)
ylimits <- c(0.0, 10.0)
xlimits <- c(0.0, 10000)
ylimits <- c(0.0, 10.0)
# create subplot for all the different levels
nrow = ceiling(sqrt(length(plot.levels)))
par(mfrow=c(nrow, nrow))
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
# empty plot
plot(numeric(0), numeric(0), xlim=xlimits, ylim=ylimits)
# find the simulation rows for the level
gal_rows <- which(pars[[f.level]]==p.level)
# plot all the single simulations for the level
for (k in gal_rows){
points(x[[id]][[k]]$time, x[[id]][[k]][[2]],
type='l', col=rgb(0.5,0.5,0.5, alpha=0.1 ))
}
}
par(mfrow=c(1,1))
id = 'PV__gal'
f.level = "gal_challenge"  # "PP__gal"
# set the minimal and maximal time for plotting
xlimits <- c(1800, 2500)
ylimits <- c(0.0, 7.0)
# create subplot for all the different levels
nrow = ceiling(sqrt(length(plot.levels)))
par(mfrow=c(nrow, nrow))
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
# empty plot
plot(numeric(0), numeric(0), xlim=xlimits, ylim=ylimits)
# find the simulation rows for the level
gal_rows <- which(pars[[f.level]]==p.level)
# plot all the single simulations for the level
for (k in gal_rows){
points(x[[id]][[k]]$time, x[[id]][[k]][[2]],
type='l', col=rgb(0.5,0.5,0.5, alpha=0.1 ))
}
}
par(mfrow=c(1,1))
xlimits <- c(1800, 2500)
ylimits <- c(0.0, 7.0)
col <- rgb(0.5,0.5,0.5, alpha=0.3 )
# create subplot for all the different levels
nrow = ceiling(sqrt(length(plot.levels)))
par(mfrow=c(nrow, nrow))
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
# empty plot
plot(numeric(0), numeric(0), xlim=xlimits, ylim=ylimits)
# find the simulation rows for the level
gal_rows <- which(pars[[f.level]]==p.level)
# plot all the single simulations for the level
for (k in gal_rows){
points(x[[id]][[k]]$time, x[[id]][[k]][[2]],
type='l', )
}
}
par(mfrow=c(1,1))
id = 'PV__gal'
f.level = "gal_challenge"  # "PP__gal"
# set the minimal and maximal time for plotting
xlimits <- c(1800, 2500)
ylimits <- c(0.0, 7.0)
col <- rgb(0.5,0.5,0.5, alpha=0.3 )
# create subplot for all the different levels
nrow = ceiling(sqrt(length(plot.levels)))
par(mfrow=c(nrow, nrow))
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
# empty plot
plot(numeric(0), numeric(0), xlim=xlimits, ylim=ylimits)
# find the simulation rows for the level
gal_rows <- which(pars[[f.level]]==p.level)
# plot all the single simulations for the level
for (k in gal_rows){
points(x[[id]][[k]]$time, x[[id]][[k]][[2]],
type='l', col=col)
}
}
par(mfrow=c(1,1))
colors = list()
id = 'PV__gal'
f.level = "gal_challenge"  # "PP__gal"
# set the minimal and maximal time for plotting
xlimits <- c(1800, 2500)
ylimits <- c(0.0, 7.0)
colors = list()
colors[[id]] <- rgb(0.5,0.5,0.5, alpha=0.3)
# create subplot for all the different levels
nrow = ceiling(sqrt(length(plot.levels)))
par(mfrow=c(nrow, nrow))
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
# empty plot
plot(numeric(0), numeric(0), xlim=xlimits, ylim=ylimits,
main=paste(f.level, '=' p.level))
# find the simulation rows for the level &
# plot all the single simulations for the level
gal_rows <- which(pars[[f.level]]==p.level)
for (k in gal_rows){
points(x[[id]][[k]]$time, x[[id]][[k]][[2]],
type='l', col=colors[[id]])
}
}
par(mfrow=c(1,1))
id = 'PV__gal'
f.level = "gal_challenge"  # "PP__gal"
# set the minimal and maximal time for plotting
xlimits <- c(1800, 2500)
ylimits <- c(0.0, 7.0)
colors = list()
colors[[id]] <- rgb(0.5,0.5,0.5, alpha=0.3)
# create subplot for all the different levels
nrow = ceiling(sqrt(length(plot.levels)))
par(mfrow=c(nrow, nrow))
plot.levels <- levels(as.factor(pars[[f.level]]))
par(mfrow=c(nrow, nrow))
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
# empty plot
plot(numeric(0), numeric(0), xlim=xlimits, ylim=ylimits,
main=paste(f.level, '=' p.level))
# find the simulation rows for the level &
# plot all the single simulations for the level
gal_rows <- which(pars[[f.level]]==p.level)
for (k in gal_rows){
points(x[[id]][[k]]$time, x[[id]][[k]][[2]],
type='l', col=colors[[id]])
}
}
par(mfrow=c(1,1))
plot(numeric(0), numeric(0), xlim=xlimits, ylim=ylimits,
main=paste(f.level, '=' p.level))
# create subplot for all the different levels
nrow = ceiling(sqrt(length(plot.levels)))
par(mfrow=c(nrow, nrow))
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
# empty plot
plot(numeric(0), numeric(0), xlim=xlimits, ylim=ylimits,
main=paste(f.level, '=', p.level))
# find the simulation rows for the level &
# plot all the single simulations for the level
gal_rows <- which(pars[[f.level]]==p.level)
for (k in gal_rows){
points(x[[id]][[k]]$time, x[[id]][[k]][[2]],
type='l', col=colors[[id]])
}
}
par(mfrow=c(1,1))
plot.ids = c('PP__gal', 'PV__gal')
plot.colors = c( rgb(0.5,0.5,0.5, alpha=0.3), rgb(0.5,0.5,1.0, alpha=0.3) )
names(plot.colors) <- plot.ids
plot.colors
# which id splitted under which levels
plot.ids = c('PP__gal', 'PV__gal')
plot.colors = c( rgb(0.5,0.5,0.5, alpha=0.3), rgb(0.5,0.5,1.0, alpha=0.3) )
names(plot.colors) <- plot.ids
f.level = "gal_challenge"  # "PP__gal"
# set the minimal and maximal time for plotting
xlimits <- c(1800, 2500)
ylimits <- c(0.0, 7.0)
# create subplot for all the different levels
nrow = ceiling(sqrt(length(plot.levels)))
par(mfrow=c(nrow, nrow))
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
# empty plot
plot(numeric(0), numeric(0), xlim=xlimits, ylim=ylimits,
main=paste(f.level, '=', p.level))
# find the simulation rows for the level &
# plot all the single simulations for the level
gal_rows <- which(pars[[f.level]]==p.level)
for (k in gal_rows){
for (id in plot.ids){
points(x[[id]][[k]]$time, x[[id]][[k]][[2]],
type='l', col=plot.colors[[id]])
}
}
}
par(mfrow=c(1,1))
createApproximationMatrix(ids, simIds, t.approx){
Ntime <- length(t.approx)
Nsim <- length(simIds)
# setup the results list
mlist <- vector('list', length(ids))
names(mlist) <- ids
for (id in ids){
# setup the empty matrix
mlist[[id]] <- matrix(data=NA, nrow=Ntime, ncol=Nsim)
colnames(mlist[[id]]) <- simIds
rownames(mlist[[id]]) <- t.approx
# fill the matrix with interpolated data
for(ks in seq(Nsim)){
datalist <- x[[id]]
data.interp <- approx(datalist[[ks]][, 'time'], datalist[[ks]][, 2], xout=time, method="linear")
mlist[[id]][, ks] <- data.interp[[2]]
}
}
return(mat)
}
createApproximationMatrix <- function(ids, simIds, t.approx){
Ntime <- length(t.approx)
Nsim <- length(simIds)
# setup the results list
mlist <- vector('list', length(ids))
names(mlist) <- ids
for (id in ids){
# setup the empty matrix
mlist[[id]] <- matrix(data=NA, nrow=Ntime, ncol=Nsim)
colnames(mlist[[id]]) <- simIds
rownames(mlist[[id]]) <- t.approx
# fill the matrix with interpolated data
for(ks in seq(Nsim)){
datalist <- x[[id]]
data.interp <- approx(datalist[[ks]][, 'time'], datalist[[ks]][, 2], xout=time, method="linear")
mlist[[id]][, ks] <- data.interp[[2]]
}
}
return(mlist)
}
mlist <- createApproximationMatrix(ids=ids, simIds=simIds, t.approx=t.approx)
t.approx = seq(from=1995, to=2200, by=5)
mlist <- createApproximationMatrix(ids=ids, simIds=simIds, t.approx=t.approx)
t.approx
mlist <- createApproximationMatrix(ids=ids, simIds=simIds, t.approx=t.approx)
print(head(datalist))
datalist <- x[[id]]
print(head(datalist))
createApproximationMatrix <- function(ids, simIds, t.approx){
Ntime <- length(t.approx)
Nsim <- length(simIds)
# setup the results list
mlist <- vector('list', length(ids))
names(mlist) <- ids
for (id in ids){
# setup the empty matrix
mlist[[id]] <- matrix(data=NA, nrow=Ntime, ncol=Nsim)
colnames(mlist[[id]]) <- simIds
rownames(mlist[[id]]) <- t.approx
# fill the matrix with interpolated data
for(ks in seq(Nsim)){
datalist <- x[[id]]
print(head(datalist))
data.interp <- approx(datalist[[ks]][, 'time'], datalist[[ks]][, 2], xout=time, method="linear")
mlist[[id]][, ks] <- data.interp[[2]]
}
}
return(mlist)
}
mlist <- createApproximationMatrix(ids=ids, simIds=simIds, t.approx=t.approx)
createApproximationMatrix <- function(ids, simIds, t.approx){
Ntime <- length(t.approx)
Nsim <- length(simIds)
# setup the results list
mlist <- vector('list', length(ids))
names(mlist) <- ids
for (id in ids){
# setup the empty matrix
mlist[[id]] <- matrix(data=NA, nrow=Ntime, ncol=Nsim)
colnames(mlist[[id]]) <- simIds
rownames(mlist[[id]]) <- t.approx
# fill the matrix with interpolated data
for(ks in seq(Nsim)){
datalist <- x[[id]]
print(head(datalist))
data.interp <- approx(datalist[[ks]][, 'time'], datalist[[ks]][, 2], xout=t.approx, method="linear")
mlist[[id]][, ks] <- data.interp[[2]]
}
}
return(mlist)
}
mlist <- createApproximationMatrix(ids=ids, simIds=simIds, t.approx=t.approx)
t.approx
mlist <- createApproximationMatrix(ids=ids, simIds=simIds, t.approx=t.approx)
createApproximationMatrix <- function(ids, simIds, t.approx){
Ntime <- length(t.approx)
Nsim <- length(simIds)
# setup the results list
mlist <- vector('list', length(ids))
names(mlist) <- ids
for (id in ids){
# setup the empty matrix
mlist[[id]] <- matrix(data=NA, nrow=Ntime, ncol=Nsim)
colnames(mlist[[id]]) <- simIds
rownames(mlist[[id]]) <- t.approx
# fill the matrix with interpolated data
for(ks in seq(Nsim)){
datalist <- x[[id]]
data.interp <- approx(datalist[[ks]][, 'time'], datalist[[ks]][, 2], xout=t.approx, method="linear")
mlist[[id]][, ks] <- data.interp[[2]]
}
}
return(mlist)
}
mlist <- createApproximationMatrix(ids=ids, simIds=simIds, t.approx=t.approx)
f.level = "gal_challenge"  # "PP__gal"
plot.levels <- levels(as.factor(pars[[f.level]]))
pars$F <- pi*(pars$y_sin^2) * pars$flow_sin
plot(pars$flow_sin, pars$F)
plot(pars$y_sin, pars$F)
plot(pars$flow_sin, pars$F)
stats <- list('vector', Ntime)
stats <- list('vector', length(t.approx))
stats
plotMeanCurves <- function(mat){
for (kc in seq(length(compounds))){
compound <- compounds[kc]
col <- ccolors[kc]
id <- paste('PV__', compound, sep='')
for (gal_level in gal_levels){
# find the simulation rows for the level
gal_rows <- which(pars$PP__gal==gal_level)
tmp <- mat[[id]][,gal_rows]
w <- pars$F[gal_rows] # weighting with the volume flow F
row.means <- rowMeans(tmp)
row.wmeans <- rowWeightedMeans(tmp, w=w)
row.medians <- rowMedians(tmp)
row.wmedians <- rowWeightedMedians(tmp, w=w)
points(time, row.wmeans, col=col, lwd=2, type='l', lty=1)
points(time, row.wmedians, col=col, lwd=2, type='l', lty=2)
#points(time, row.means, col=col, lwd=2, type='l', lty=1)
#points(time, rowMedians(tmp), col=col, lwd=2, type='l', lty=3)
#points(time, rowMins(tmp), col='Red', lwd=2, type='l', lty=2)
#points(time, rowMaxs(tmp), col='Red', lwd=2, type='l', lty=2)
#points(time, rowQuantiles(tmp,probs=c(0.25)), col='Green', lwd=2, type='l', lty=3)
#points(time, rowQuantiles(tmp,probs=c(0.75)), col='Green', lwd=2, type='l', lty=3)
# lines for the max values
tmax.wmeans <- time[which.max(row.wmeans)]
cat("tmax [", id , "] = ", tmax.wmeans, "\n")
tmax.means <- time[which.max(row.means)]
abline(v=tmax.wmeans, col=col)
#abline(v=tmax.means, col=col)
}
}
}
plot(numeric(0), numeric(0), log='y', xlim=c(min(t.approx), max(t.approx)), ylim=c(0,7))
plotMeanCurves(mat=mlist)
library('matrixStats')
compounds = c('gal', 'galM', 'rbcM', 'alb', 'suc', 'h2oM')
ccolors = c('gray', 'black', 'red', 'darkgreen', 'darkorange', 'darkblue')
plot(numeric(0), numeric(0), log='y', xlim=c(min(t.approx), max(t.approx)), ylim=c(0,7))
plotMeanCurves(mat=mlist)
plotMeanCurves <- function(mlist, f.level, compounds, ccolors){
for (kc in seq(length(compounds))){
compound <- compounds[kc]
col <- ccolors[kc]
id <- paste('PV__', compound, sep='')
# different levels
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
sim_rows <- which(pars[[f.level]]==p.level)
tmp <- mlist[[id]][ ,sim_rows]
w <- pars$F[sim_rows] # weighting with the volume flow F
row.means <- rowMeans(tmp)
row.wmeans <- rowWeightedMeans(tmp, w=w)
row.medians <- rowMedians(tmp)
row.wmedians <- rowWeightedMedians(tmp, w=w)
points(time, row.wmeans, col=col, lwd=2, type='l', lty=1)
points(time, row.wmedians, col=col, lwd=2, type='l', lty=2)
#points(time, row.means, col=col, lwd=2, type='l', lty=1)
#points(time, rowMedians(tmp), col=col, lwd=2, type='l', lty=3)
#points(time, rowMins(tmp), col='Red', lwd=2, type='l', lty=2)
#points(time, rowMaxs(tmp), col='Red', lwd=2, type='l', lty=2)
#points(time, rowQuantiles(tmp,probs=c(0.25)), col='Green', lwd=2, type='l', lty=3)
#points(time, rowQuantiles(tmp,probs=c(0.75)), col='Green', lwd=2, type='l', lty=3)
# lines for the max values
tmax.wmeans <- time[which.max(row.wmeans)]
cat("tmax [", id , "] = ", tmax.wmeans, "\n")
tmax.means <- time[which.max(row.means)]
abline(v=tmax.wmeans, col=col)
#abline(v=tmax.means, col=col)
}
}
}
plotMeanCurves <- function(mlist, f.level, compounds, ccolors){
for (kc in seq(length(compounds))){
compound <- compounds[kc]
col <- ccolors[kc]
id <- paste('PV__', compound, sep='')
# different levels
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
sim_rows <- which(pars[[f.level]]==p.level)
tmp <- mlist[[id]][ ,sim_rows]
w <- pars$F[sim_rows] # weighting with the volume flow F
row.means <- rowMeans(tmp)
row.wmeans <- rowWeightedMeans(tmp, w=w)
row.medians <- rowMedians(tmp)
row.wmedians <- rowWeightedMedians(tmp, w=w)
points(time, row.wmeans, col=col, lwd=2, type='l', lty=1)
points(time, row.wmedians, col=col, lwd=2, type='l', lty=2)
#points(time, row.means, col=col, lwd=2, type='l', lty=1)
#points(time, rowMedians(tmp), col=col, lwd=2, type='l', lty=3)
#points(time, rowMins(tmp), col='Red', lwd=2, type='l', lty=2)
#points(time, rowMaxs(tmp), col='Red', lwd=2, type='l', lty=2)
#points(time, rowQuantiles(tmp,probs=c(0.25)), col='Green', lwd=2, type='l', lty=3)
#points(time, rowQuantiles(tmp,probs=c(0.75)), col='Green', lwd=2, type='l', lty=3)
# lines for the max values
tmax.wmeans <- time[which.max(row.wmeans)]
cat("tmax [", id , "] = ", tmax.wmeans, "\n")
tmax.means <- time[which.max(row.means)]
abline(v=tmax.wmeans, col=col)
#abline(v=tmax.means, col=col)
}
}
}
plot(numeric(0), numeric(0), log='y', xlim=c(min(t.approx), max(t.approx)), ylim=c(0,7))
plotMeanCurves(mlist, f.level, compounds=compounds, ccolors=ccolors)
plot(numeric(0), numeric(0), xlim=c(min(t.approx), max(t.approx)), ylim=c(0,7))
plotMeanCurves(mlist, f.level, compounds=compounds, ccolors=ccolors)
plotMeanCurves(mlist, f.level, compounds=compounds, ccolors=ccolors)
plotMeanCurves <- function(mlist, f.level, compounds, ccolors){
for (kc in seq(length(compounds))){
compound <- compounds[kc]
col <- ccolors[kc]
id <- paste('PV__', compound, sep='')
# different levels
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
sim_rows <- which(pars[[f.level]]==p.level)
tmp <- mlist[[id]][ ,sim_rows]
w <- pars$F[sim_rows] # weighting with the volume flow F
row.means <- rowMeans(tmp)
row.wmeans <- rowWeightedMeans(tmp, w=w)
row.medians <- rowMedians(tmp)
row.wmedians <- rowWeightedMedians(tmp, w=w)
time = as.numeric(rownames(tmp))
points(time, row.wmeans, col=col, lwd=2, type='l', lty=1)
points(time, row.wmedians, col=col, lwd=2, type='l', lty=2)
#points(time, row.means, col=col, lwd=2, type='l', lty=1)
#points(time, rowMedians(tmp), col=col, lwd=2, type='l', lty=3)
#points(time, rowMins(tmp), col='Red', lwd=2, type='l', lty=2)
#points(time, rowMaxs(tmp), col='Red', lwd=2, type='l', lty=2)
#points(time, rowQuantiles(tmp,probs=c(0.25)), col='Green', lwd=2, type='l', lty=3)
#points(time, rowQuantiles(tmp,probs=c(0.75)), col='Green', lwd=2, type='l', lty=3)
# lines for the max values
tmax.wmeans <- time[which.max(row.wmeans)]
cat("tmax [", id , "] = ", tmax.wmeans, "\n")
tmax.means <- time[which.max(row.means)]
abline(v=tmax.wmeans, col=col)
#abline(v=tmax.means, col=col)
}
}
}
plot(numeric(0), numeric(0), xlim=c(min(t.approx), max(t.approx)), ylim=c(0,7))
plotMeanCurves(mlist, f.level, compounds=compounds, ccolors=ccolors)
plotMeanCurves <- function(mlist, f.level, compounds, ccolors){
for (kc in seq(length(compounds))){
compound <- compounds[kc]
col <- ccolors[kc]
id <- paste('PV__', compound, sep='')
# different levels
plot.levels <- levels(as.factor(pars[[f.level]]))
for (p.level in plot.levels){
sim_rows <- which(pars[[f.level]]==p.level)
tmp <- mlist[[id]][ ,sim_rows]
w <- pars$F[sim_rows] # weighting with the volume flow F
row.means <- rowMeans(tmp)
row.wmeans <- rowWeightedMeans(tmp, w=w)
row.medians <- rowMedians(tmp)
row.wmedians <- rowWeightedMedians(tmp, w=w)
row.sds <- rowSds(tmp)
time = as.numeric(rownames(tmp))
points(time, row.wmeans, col=col, lwd=2, type='l', lty=1)
points(time, row.wmeans+row.sds, col='Orange', lwd=2, type='l', lty=1)
points(time, row.wmedians, col=col, lwd=2, type='l', lty=2)
#points(time, row.means, col=col, lwd=2, type='l', lty=1)
#points(time, rowMedians(tmp), col=col, lwd=2, type='l', lty=3)
#points(time, rowMins(tmp), col='Red', lwd=2, type='l', lty=2)
#points(time, rowMaxs(tmp), col='Red', lwd=2, type='l', lty=2)
#points(time, rowQuantiles(tmp,probs=c(0.25)), col='Green', lwd=2, type='l', lty=3)
#points(time, rowQuantiles(tmp,probs=c(0.75)), col='Green', lwd=2, type='l', lty=3)
# lines for the max values
tmax.wmeans <- time[which.max(row.wmeans)]
cat("tmax [", id , "] = ", tmax.wmeans, "\n")
tmax.means <- time[which.max(row.means)]
abline(v=tmax.wmeans, col=col)
#abline(v=tmax.means, col=col)
}
}
}
# Gal challenge
plot(numeric(0), numeric(0), xlim=c(min(t.approx), max(t.approx)), ylim=c(0,7))
plotMeanCurves(mlist, f.level, compounds=compounds, ccolors=ccolors)
