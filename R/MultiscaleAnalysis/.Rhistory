}
# Preprocess the parameters for scaling
Ntask = length(tasks)
pars.task <- list()
pars.mat <- list()
pars.list <- list()
for (kt in seq(Ntask)){
task <- tasks[kt]
peak <- peaks[kt]
modelId <- paste('MultipleIndicator_', peak, '_', version, '_Nc20_Nf1', sep='')
parsfile <- file.path(ma.settings$dir.results, sname,
paste(task, '_', modelId, '_parameters.csv', sep=""))
# Load the data
load(file=outfileFromParsFile(parsfile))
# Parameter processing
ps <- getParameterTypes(pars=pars)
# Extend the parameters with the SBML parameters and calculated parameters
fsbml <- file.path(ma.settings$dir.results, sname, paste(modelId, '.xml', sep=''))
model <- loadSBMLModel(fsbml)
pars <- extendParameterStructure(pars=pars, fixed_ps=ps$fixed, model=model)
head(pars)
# Standard distributions for normal case
p.gen <- loadStandardDistributions()
print(p.gen)
# ECDFs for standard distributions
ecdf.list <- createListOfStandardECDF(p.gen, ps$var)
# Calculate the probabilites for single variables
pars <- calculateProbabilitiesForVariables(pars, ecdf.list)
# And the overall probability per sample
pars <- calculateSampleProbability(pars, ps$var)
head(pars)
# Color definition based on probabilities
weights <- NULL
# weights = pars$p_sample
if (is.null(weigths)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
# Create the plots
time = getTimeFromPreprocessMatrix(preprocess.mat)-10.0
plotMultipleIndicatorCurves(time, preprocess.mat, weights=weights, ccols=ccols, create_plot_files=T)
plotMultipleIndicatorMean(time, preprocess.mat, weights=weights, create_plot_files=T)
}
# Preprocess the parameters for scaling
Ntask = length(tasks)
pars.task <- list()
pars.mat <- list()
pars.list <- list()
for (kt in seq(Ntask)){
task <- tasks[kt]
peak <- peaks[kt]
modelId <- paste('MultipleIndicator_', peak, '_', version, '_Nc20_Nf1', sep='')
parsfile <- file.path(ma.settings$dir.results, sname,
paste(task, '_', modelId, '_parameters.csv', sep=""))
# Load the data
load(file=outfileFromParsFile(parsfile))
# Parameter processing
ps <- getParameterTypes(pars=pars)
# Extend the parameters with the SBML parameters and calculated parameters
fsbml <- file.path(ma.settings$dir.results, sname, paste(modelId, '.xml', sep=''))
model <- loadSBMLModel(fsbml)
pars <- extendParameterStructure(pars=pars, fixed_ps=ps$fixed, model=model)
head(pars)
# Standard distributions for normal case
p.gen <- loadStandardDistributions()
print(p.gen)
# ECDFs for standard distributions
ecdf.list <- createListOfStandardECDF(p.gen, ps$var)
# Calculate the probabilites for single variables
pars <- calculateProbabilitiesForVariables(pars, ecdf.list)
# And the overall probability per sample
pars <- calculateSampleProbability(pars, ps$var)
head(pars)
# Color definition based on probabilities
weights <- NULL
# weights = pars$p_sample
if (is.null(weigths)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
# Create the plots
time = getTimeFromPreprocessMatrix(preprocess.mat)-10.0
# plotMultipleIndicatorCurves(time, preprocess.mat, weights=weights, ccols=ccols, create_plot_files=T)
# plotMultipleIndicatorMean(time, preprocess.mat, weights=weights, create_plot_files=T)
}
# Colors for weights
getColorsForWeights <- function (weights) {
print('getColorsForWeights')
ccol = 'gray'
Nsim = nrow(pars)
Ncol = 7
colpal <- brewer.pal(Ncol+2, 'Greys')
ccols = rep(colpal[1], Nsim)
maxValue = max(weights)
bw = maxValue/Ncol
for (k in seq(Ncol)){
ind <- which( (weights>((k-1)*bw)) & (weights <= (k*bw)))
ccols[ind] = colpal[k+2]
ccols[ind] = col2rgb_alpha(colpal[k+2], 0.7)
}
ccols
# Colors for weights
getColorsForWeights <- function (weights) {
print('getColorsForWeights')
ccol = 'gray'
Nsim = nrow(pars)
Ncol = 7
colpal <- brewer.pal(Ncol+2, 'Greys')
ccols = rep(colpal[1], Nsim)
maxValue = max(weights)
bw = maxValue/Ncol
for (k in seq(Ncol)){
ind <- which( (weights>((k-1)*bw)) & (weights <= (k*bw)))
ccols[ind] = colpal[k+2]
ccols[ind] = col2rgb_alpha(colpal[k+2], 0.7)
}
ccols
}
weights <- NULL
# weights = pars$p_sample
if (is.null(weigths)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
# Create the plots
time = getTimeFromPreprocessMatrix(preprocess.mat)-10.0
# Preprocess the parameters for scaling
Ntask = length(tasks)
pars.task <- list()
pars.mat <- list()
pars.list <- list()
for (kt in seq(Ntask)){
task <- tasks[kt]
peak <- peaks[kt]
modelId <- paste('MultipleIndicator_', peak, '_', version, '_Nc20_Nf1', sep='')
parsfile <- file.path(ma.settings$dir.results, sname,
paste(task, '_', modelId, '_parameters.csv', sep=""))
# Load the data
load(file=outfileFromParsFile(parsfile))
# Parameter processing
ps <- getParameterTypes(pars=pars)
# Extend the parameters with the SBML parameters and calculated parameters
fsbml <- file.path(ma.settings$dir.results, sname, paste(modelId, '.xml', sep=''))
model <- loadSBMLModel(fsbml)
pars <- extendParameterStructure(pars=pars, fixed_ps=ps$fixed, model=model)
head(pars)
# Standard distributions for normal case
p.gen <- loadStandardDistributions()
print(p.gen)
# ECDFs for standard distributions
ecdf.list <- createListOfStandardECDF(p.gen, ps$var)
# Calculate the probabilites for single variables
pars <- calculateProbabilitiesForVariables(pars, ecdf.list)
# And the overall probability per sample
pars <- calculateSampleProbability(pars, ps$var)
head(pars)
# Color definition based on probabilities
weights <- NULL
# weights = pars$p_sample
if (is.null(weigths)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
# Create the plots
time = getTimeFromPreprocessMatrix(preprocess.mat)-10.0
# plotMultipleIndicatorCurves(time, preprocess.mat, weights=weights, ccols=ccols, create_plot_files=T)
# plotMultipleIndicatorMean(time, preprocess.mat, weights=weights, create_plot_files=T)
}
# Preprocess the parameters for scaling
Ntask = length(tasks)
pars.task <- list()
pars.mat <- list()
pars.list <- list()
for (kt in seq(Ntask)){
task <- tasks[kt]
peak <- peaks[kt]
modelId <- paste('MultipleIndicator_', peak, '_', version, '_Nc20_Nf1', sep='')
parsfile <- file.path(ma.settings$dir.results, sname,
paste(task, '_', modelId, '_parameters.csv', sep=""))
# Load the data
load(file=outfileFromParsFile(parsfile))
# Parameter processing
ps <- getParameterTypes(pars=pars)
# Extend the parameters with the SBML parameters and calculated parameters
fsbml <- file.path(ma.settings$dir.results, sname, paste(modelId, '.xml', sep=''))
model <- loadSBMLModel(fsbml)
pars <- extendParameterStructure(pars=pars, fixed_ps=ps$fixed, model=model)
head(pars)
# Standard distributions for normal case
p.gen <- loadStandardDistributions()
print(p.gen)
# ECDFs for standard distributions
ecdf.list <- createListOfStandardECDF(p.gen, ps$var)
# Calculate the probabilites for single variables
pars <- calculateProbabilitiesForVariables(pars, ecdf.list)
# And the overall probability per sample
pars <- calculateSampleProbability(pars, ps$var)
head(pars)
# Color definition based on probabilities
weights <- NULL
# weights = pars$p_sample
if (is.null(weigths)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
# Create the plots
time = getTimeFromPreprocessMatrix(preprocess.mat)-10.0
plotMultipleIndicatorCurves(time, preprocess.mat, weights=weights, ccols=ccols, create_plot_files=T)
# plotMultipleIndicatorMean(time, preprocess.mat, weights=weights, create_plot_files=T)
}
}
# Preprocess the parameters for scaling
Ntask = length(tasks)
pars.task <- list()
pars.mat <- list()
pars.list <- list()
for (kt in seq(Ntask)){
task <- tasks[kt]
peak <- peaks[kt]
modelId <- paste('MultipleIndicator_', peak, '_', version, '_Nc20_Nf1', sep='')
parsfile <- file.path(ma.settings$dir.results, sname,
paste(task, '_', modelId, '_parameters.csv', sep=""))
# Load the data
load(file=outfileFromParsFile(parsfile))
# Parameter processing
ps <- getParameterTypes(pars=pars)
# Extend the parameters with the SBML parameters and calculated parameters
fsbml <- file.path(ma.settings$dir.results, sname, paste(modelId, '.xml', sep=''))
model <- loadSBMLModel(fsbml)
pars <- extendParameterStructure(pars=pars, fixed_ps=ps$fixed, model=model)
head(pars)
# Standard distributions for normal case
p.gen <- loadStandardDistributions()
print(p.gen)
# ECDFs for standard distributions
ecdf.list <- createListOfStandardECDF(p.gen, ps$var)
# Calculate the probabilites for single variables
pars <- calculateProbabilitiesForVariables(pars, ecdf.list)
# And the overall probability per sample
pars <- calculateSampleProbability(pars, ps$var)
head(pars)
# Color definition based on probabilities
weights <- NULL
# weights = pars$p_sample
if (is.null(weigths)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
# Create the plots
time = getTimeFromPreprocessMatrix(preprocess.mat)-10.0
plotMultipleIndicatorCurves(time, preprocess.mat, weights=weights, ccols=ccols, create_plot_files=T)
# plotMultipleIndicatorMean(time, preprocess.mat, weights=weights, create_plot_files=T)
}
print('Calculate probabilities')
# Calculate the probabilites for single variables
pars <- calculateProbabilitiesForVariables(pars, ecdf.list)
# And the overall probability per sample
pars <- calculateSampleProbability(pars, ps$var)
head(pars)
# Color definition based on probabilities
print('Assign weights')
weights <- NULL
# weights = pars$p_sample
if (is.null(weigths)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
weights = NULL
weights <- NULL
# weights = pars$p_sample
if (is.null(weigths)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
ccols <- getColorsForWeights(weights)
ccols <- NULL
ccols <- getColorsForWeights(weights)
print('Assign weights')
weights <- NULL
# weights = pars$p_sample
if (is.null(weigths)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
weights <- NULL
# weights = pars$p_sample
if (is.null(weigths)){
print('is null')
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
# weights = pars$p_sample
if (is.null(weigths)){
print('is null')
ccols <- NULL
}else{
print('is not null')
ccols <- getColorsForWeights(weights)
}
# Preprocess the parameters for scaling
Ntask = length(tasks)
pars.task <- list()
pars.mat <- list()
pars.list <- list()
for (kt in seq(Ntask)){
task <- tasks[kt]
peak <- peaks[kt]
modelId <- paste('MultipleIndicator_', peak, '_', version, '_Nc20_Nf1', sep='')
parsfile <- file.path(ma.settings$dir.results, sname,
paste(task, '_', modelId, '_parameters.csv', sep=""))
# Load the data
load(file=outfileFromParsFile(parsfile))
# Parameter processing
ps <- getParameterTypes(pars=pars)
# Extend the parameters with the SBML parameters and calculated parameters
fsbml <- file.path(ma.settings$dir.results, sname, paste(modelId, '.xml', sep=''))
model <- loadSBMLModel(fsbml)
pars <- extendParameterStructure(pars=pars, fixed_ps=ps$fixed, model=model)
head(pars)
# Standard distributions for normal case
p.gen <- loadStandardDistributions()
print(p.gen)
# ECDFs for standard distributions
ecdf.list <- createListOfStandardECDF(p.gen, ps$var)
# Calculate the probabilites for single variables
pars <- calculateProbabilitiesForVariables(pars, ecdf.list)
# And the overall probability per sample
pars <- calculateSampleProbability(pars, ps$var)
head(pars)
# Color definition based on probabilities
weights <- NULL
# weights = pars$p_sample
if (is.null(weights)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
# Create the plots
time = getTimeFromPreprocessMatrix(preprocess.mat)-10.0
plotMultipleIndicatorCurves(time, preprocess.mat, weights=weights, ccols=ccols, create_plot_files=T)
# plotMultipleIndicatorMean(time, preprocess.mat, weights=weights, create_plot_files=T)
}
Ntask = length(tasks)
pars.task <- list()
pars.mat <- list()
pars.list <- list()
for (kt in seq(Ntask)){
task <- tasks[kt]
peak <- peaks[kt]
modelId <- paste('MultipleIndicator_', peak, '_', version, '_Nc20_Nf1', sep='')
parsfile <- file.path(ma.settings$dir.results, sname,
paste(task, '_', modelId, '_parameters.csv', sep=""))
# Load the data
load(file=outfileFromParsFile(parsfile))
# Parameter processing
ps <- getParameterTypes(pars=pars)
# Extend the parameters with the SBML parameters and calculated parameters
fsbml <- file.path(ma.settings$dir.results, sname, paste(modelId, '.xml', sep=''))
model <- loadSBMLModel(fsbml)
pars <- extendParameterStructure(pars=pars, fixed_ps=ps$fixed, model=model)
head(pars)
# Standard distributions for normal case
p.gen <- loadStandardDistributions()
print(p.gen)
# ECDFs for standard distributions
ecdf.list <- createListOfStandardECDF(p.gen, ps$var)
# Calculate the probabilites for single variables
pars <- calculateProbabilitiesForVariables(pars, ecdf.list)
# And the overall probability per sample
pars <- calculateSampleProbability(pars, ps$var)
head(pars)
# Color definition based on probabilities
weights <- NULL
# weights = pars$p_sample
if (is.null(weights)){
ccols <- NULL
}else{
ccols <- getColorsForWeights(weights)
}
# Create the plots
time = getTimeFromPreprocessMatrix(preprocess.mat)-10.0
plotMultipleIndicatorCurves(time, preprocess.mat, weights=weights, ccols=ccols, create_plot_files=T)
plotMultipleIndicatorMean(time, preprocess.mat, weights=weights, create_plot_files=T)
}
# calculate the maximum values
maxTimes <- function(data){
Nsim = ncol(data)
maxtime <- data.frame(tmp=numeric(Nsim))
for (kc in seq(1, length(compounds)) ){
name = paste("PV__", compounds[kc], sep="")
print(name)
maxtime[[name]] <- numeric(Nsim)
# find the max values for all simulations
for (k in seq(1, Nsim)){
maxtime[[name]][k] = time[ which.max(dilmat[[name]][,k]) ]
}
}
}
# Load the experimental data
gor1973 <- read.csv(file.path(ma.settings$dir.expdata, "dilution_indicator", "Goresky1973_Fig1.csv"), sep="\t")
summary(gor1973)
# Units: time [s], compound: 1000*outflow fraction/ml
gor1983 <- read.csv(file.path(ma.settings$dir.expdata, "dilution_indicator", "Goresky1983_Fig1.csv"), sep="\t")
summary(gor1983)
name="PV__rbcM"
time <- getTimeFromPreprocessMatrix(preprocess.mat) - 10.0
plotCompound(time, preprocess.mat[[name]], name, col=ccolors[name], ylim=c(0,1.2))
name="PV__rbcM"
time <- getTimeFromPreprocessMatrix(preprocess.mat) - 10.0
plotCompound(time, preprocess.mat[[name]], name, col=ccolors[name], ylim=c(0,1.2))
dev.off()
boxplot(preprocess.mat[[name]][1:40, 1:100])
plot2Ddensity(time, preprocess.mat[[name]][,], name, col=ccolors[name], ylim=c(0,0.8))
compounds = c( 'rbcM', 'alb', 'suc', 'h2oM')
ccolors = c('red', 'darkgreen', 'darkorange', 'darkblue' )
# Load the experimental data
gor1973 <- read.csv(file.path(ma.settings$dir.expdata, "dilution_indicator", "Goresky1973_Fig1.csv"), sep="\t")
summary(gor1973)
# Units: time [s], compound: 1000*outflow fraction/ml
gor1983 <- read.csv(file.path(ma.settings$dir.expdata, "dilution_indicator", "Goresky1983_Fig1.csv"), sep="\t")
summary(gor1983)
## Combined Dilution Curves in one plot ##
compounds = c('gal', 'rbcM', 'alb', 'suc', 'h2oM')
ccolors = c('black', 'red', 'darkgreen', 'darkorange', 'darkblue' )
# calculate the maximum values
maxTimes <- function(data){
Nsim = ncol(data)
maxtime <- data.frame(tmp=numeric(Nsim))
for (kc in seq(1, length(compounds)) ){
name = paste("PV__", compounds[kc], sep="")
print(name)
maxtime[[name]] <- numeric(Nsim)
# find the max values for all simulations
for (k in seq(1, Nsim)){
maxtime[[name]][k] = time[ which.max(preprocess.mat[[name]][,k]) ]
}
}
}
maxtime <- maxTimes(preprocess.mat)
# calculate the maximum values
maxTimes <- function(data){
Nsim = ncol(data)
maxtime <- data.frame(tmp=numeric(Nsim))
for (kc in seq(1, length(compounds)) ){
name = paste("PV__", compounds[kc], sep="")
print(name)
maxtime[[name]] <- numeric(Nsim)
# find the max values for all simulations
for (k in seq(1, Nsim)){
maxtime[[name]][k] = time[ which.max(preprocess.mat[[name]][,k]) ]
}
}
}
maxtime <- maxTimes(preprocess.mat)
maxTimes <- function(data){
Nsim = ncol(data)
print(Nsim)
maxtime <- data.frame(tmp=numeric(Nsim))
for (kc in seq(1, length(compounds)) ){
name = paste("PV__", compounds[kc], sep="")
print(name)
maxtime[[name]] <- numeric(Nsim)
# find the max values for all simulations
for (k in seq(1, Nsim)){
maxtime[[name]][k] = time[ which.max(preprocess.mat[[name]][,k]) ]
}
}
}
maxtime <- maxTimes(preprocess.mat)
maxTimes <- function(preprocess.mat){
Nsim = ncol(preprocess.mat[[1]])
print(Nsim)
maxtime <- data.frame(tmp=numeric(Nsim))
for (kc in seq(1, length(compounds)) ){
name = paste("PV__", compounds[kc], sep="")
print(name)
maxtime[[name]] <- numeric(Nsim)
# find the max values for all simulations
for (k in seq(1, Nsim)){
maxtime[[name]][k] = time[ which.max(preprocess.mat[[name]][,k]) ]
}
}
}
maxtime <- maxTimes(preprocess.mat)
# calculate the maximum values
maxTimes <- function(preprocess.mat){
Nsim = ncol(preprocess.mat[[1]])
print(Nsim)
maxtime <- data.frame(tmp=numeric(Nsim))
for (kc in seq(1, length(compounds)) ){
name = paste("PV__", compounds[kc], sep="")
print(name)
maxtime[[name]] <- numeric(Nsim)
# find the max values for all simulations
for (k in seq(1, Nsim)){
maxtime[[name]][k] = time[ which.max(preprocess.mat[[name]][,k]) ]
}
}
maxtime
}
maxtime <- maxTimes(preprocess.mat)
plot(maxtime)
